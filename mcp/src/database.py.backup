"""Database connection and repository layer for PM MCP Server - NO RAW SQL"""
import json
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Any, Optional, Union
from peewee import *
from config import Config

def _safe_json(val, default):
    """Safe JSON parsing with fallback"""
    if not val:
        return default
    try:
        if isinstance(val, (dict, list)):
            return val
        return json.loads(val)
    except Exception:
        return default

def _get_issue_field_json(issue, field_name):
    """Get JSON field from issue safely"""
    return _safe_json(getattr(issue, field_name, None), {})

def _get(obj, name, default=None):
    """Safe attribute getter"""
    return getattr(obj, name, default)

# Initialize database with delayed connection
db_proxy = DatabaseProxy()

class BaseModel(Model):
    """Base model with common functionality"""
    class Meta:
        database = db_proxy

    def to_dict(self) -> Dict[str, Any]:
        """Convert model to dictionary safely"""
        data = {}
        for field in self._meta.sorted_fields:
            value = getattr(self, field.name)
            if isinstance(value, datetime):
                data[field.name] = value.isoformat() + 'Z'
            elif hasattr(value, 'to_dict'):
                data[field.name] = value.to_dict()
            elif hasattr(value, 'id'):
                data[field.name] = str(value.id)
            else:
                data[field.name] = value
        return data

class Project(BaseModel):
    """Project model"""
    project_id = CharField(unique=True, index=True, max_length=64)
    project_slug = CharField(index=True, max_length=100)
    absolute_path = CharField(max_length=500)
    metadata = TextField(null=True)  # JSON
    created_utc = DateTimeField(index=True)
    updated_utc = DateTimeField(index=True)

    def get_metadata(self) -> Dict[str, Any]:
        """Safely parse metadata JSON"""
        if not self.metadata:
            return {}
        try:
            return json.loads(self.metadata)
        except (json.JSONDecodeError, TypeError):
            return {}

    @property
    def submodules(self) -> List[Dict[str, Any]]:
        return self.get_metadata().get('submodules', [])

    @property
    def vcs(self) -> Dict[str, Any]:
        return self.get_metadata().get('vcs', {})

class Issue(BaseModel):
    """Issue model with rich content"""
    project = ForeignKeyField(Project, backref='issues', on_delete='CASCADE')
    key = CharField(unique=True, index=True, max_length=50)
    title = CharField(index=True, max_length=200)
    type = CharField(index=True, max_length=20)
    status = CharField(index=True, max_length=20)
    priority = CharField(index=True, max_length=10)
    module = CharField(null=True, index=True, max_length=100)
    owner = CharField(null=True, index=True, max_length=100)
    external_id = CharField(null=True, index=True, max_length=100)

    # Rich content as JSON
    specification = TextField(null=True)
    planning = TextField(null=True)
    implementation = TextField(null=True)
    communication = TextField(null=True)
    analytics = TextField(null=True)

    created_utc = DateTimeField(index=True)
    updated_utc = DateTimeField(index=True)

    def get_json_field(self, field_name: str) -> Dict[str, Any]:
        """Safely parse JSON field"""
        field_value = getattr(self, field_name, None)
        if not field_value:
            return {}
        try:
            return json.loads(field_value)
        except (json.JSONDecodeError, TypeError):
            return {}

    @property
    def description(self) -> str:
        return self.get_json_field('specification').get('description', '')

    @property
    def acceptance_criteria(self) -> List[str]:
        return self.get_json_field('specification').get('acceptance_criteria', [])

    @property
    def dependencies(self) -> List[str]:
        return self.get_json_field('planning').get('dependencies', [])

    @property
    def estimated_effort(self) -> str:
        return self.get_json_field('planning').get('estimated_effort', '')

    @property
    def complexity(self) -> str:
        return self.get_json_field('planning').get('complexity', 'Medium')

    @property
    def branch_hint(self) -> str:
        return self.get_json_field('implementation').get('branch_hint', '')

    def to_rich_dict(self) -> Dict[str, Any]:
        """Convert to dict with all JSON properties expanded"""
        data = self.to_dict()
        data.update({
            'description': self.description,
            'acceptance_criteria': self.acceptance_criteria,
            'dependencies': self.dependencies,
            'estimated_effort': self.estimated_effort,
            'complexity': self.complexity,
            'branch_hint': self.branch_hint,
            'project_slug': self.project.project_slug,
            'project_path': self.project.absolute_path
        })
        return data

class Task(BaseModel):
    """Task model"""
    issue = ForeignKeyField(Issue, backref='tasks', on_delete='CASCADE')
    task_id = CharField(unique=True, index=True, max_length=100)
    title = CharField(max_length=200)
    status = CharField(index=True, max_length=20)
    assignee = CharField(null=True, index=True, max_length=100)
    details = TextField(null=True)  # JSON
    created_utc = DateTimeField(index=True)
    updated_utc = DateTimeField(index=True)

    def get_details(self) -> Dict[str, Any]:
        """Safely parse details JSON"""
        if not self.details:
            return {}
        try:
            return json.loads(self.details)
        except (json.JSONDecodeError, TypeError):
            return {}

    @property
    def checklist(self) -> List[Dict[str, Any]]:
        return self.get_details().get('checklist', [])

    @property
    def notes(self) -> str:
        return self.get_details().get('notes', '')

class WorkLog(BaseModel):
    """WorkLog model"""
    issue = ForeignKeyField(Issue, backref='worklogs', on_delete='CASCADE')
    task = ForeignKeyField(Task, backref='worklogs', on_delete='SET NULL', null=True)
    agent = CharField(index=True, max_length=100)
    timestamp_utc = DateTimeField(index=True)
    activity = CharField(index=True, max_length=50)
    summary = TextField()
    artifacts = TextField(null=True)  # JSON
    context = TextField(null=True)  # JSON

    def get_artifacts(self) -> List[Dict[str, Any]]:
        """Safely parse artifacts JSON"""
        if not self.artifacts:
            return []
        try:
            return json.loads(self.artifacts)
        except (json.JSONDecodeError, TypeError):
            return []

    def get_context(self) -> Dict[str, Any]:
        """Safely parse context JSON"""
        if not self.context:
            return {}
        try:
            return json.loads(self.context)
        except (json.JSONDecodeError, TypeError):
            return {}

class PMDatabase:
    """Database operations wrapper with proper Peewee usage - NO RAW SQL"""

    _db_initialized = False

    @classmethod
    def initialize(cls):
        """Initialize database connection"""
        if cls._db_initialized:
            return

        # Create database path if needed
        db_path = Config.get_database_path()
        db_path.parent.mkdir(parents=True, exist_ok=True)

        # Initialize database
        database = SqliteDatabase(str(db_path))
        db_proxy.initialize(database)

        # Create tables if needed
        database.create_tables([Project, Issue, Task, WorkLog], safe=True)
        cls._db_initialized = True

    @classmethod
    def connect(cls):
        """Connect to database"""
        if not cls._db_initialized:
            cls.initialize()
        if db_proxy.is_closed():
            db_proxy.connect()

    @classmethod
    def close(cls):
        """Close database connection"""
        if not db_proxy.is_closed():
            db_proxy.close()

    @classmethod
    def get_project(cls, project_id: str) -> Optional[Dict[str, Any]]:
        """Get project by ID using Peewee model"""
        try:
            project = Project.get(Project.project_id == project_id)
            data = project.to_dict()
            metadata = project.get_metadata()
            data.update({
                'submodules': metadata.get('submodules', []),
                'vcs': metadata.get('vcs', {}),
                'mcp': metadata.get('mcp', {})
            })
            return data
        except DoesNotExist:
            return None

    @classmethod
    def get_all_projects(cls) -> List[Dict[str, Any]]:
        """Get all projects using Peewee query"""
        projects = Project.select().order_by(Project.project_slug)
        result = []
        for project in projects:
            data = project.to_dict()
            metadata = project.get_metadata()
            data.update({
                'submodules': metadata.get('submodules', []),
                'vcs': metadata.get('vcs', {}),
                'mcp': metadata.get('mcp', {})
            })
            result.append(data)
        return result

    @classmethod
    def get_issue(cls, issue_key: str) -> Optional[Dict[str, Any]]:
        """Get issue by key using Peewee model"""
        try:
            issue = Issue.get(Issue.key == issue_key)
            return issue.to_rich_dict()
        except DoesNotExist:
            return None

    @classmethod
    def get_issues(cls, project_id: Optional[str] = None,
                   status: Optional[str] = None,
                   priority: Optional[str] = None,
                   module: Optional[str] = None,
                   owner: Optional[str] = None,
                   limit: int = 100) -> List[Dict[str, Any]]:
        """Get issues with filters using Peewee queries"""
        query = Issue.select()

        if project_id:
            query = query.join(Project).where(Project.project_id == project_id)
        if status:
            query = query.where(Issue.status == status)
        if priority:
            query = query.where(Issue.priority == priority)
        if module:
            query = query.where(Issue.module == module)
        if owner:
            query = query.where(Issue.owner == owner)

        query = query.order_by(Issue.updated_utc.desc()).limit(limit)
        return [issue.to_rich_dict() for issue in query]

    @classmethod
    def get_issue_with_relations(cls, issue_key: str) -> Optional[Dict[str, Any]]:
        """Get issue with tasks and worklogs using Peewee relationships"""
        try:
            issue = Issue.get(Issue.key == issue_key)

            # Use Peewee relationships - no raw SQL!
            tasks = []
            for task in issue.tasks:  # Auto lazy-loaded backref
                task_data = task.to_dict()
                task_data.update({
                    'checklist': task.checklist,
                    'notes': task.notes
                })
                tasks.append(task_data)

            worklogs = []
            for worklog in issue.worklogs.order_by(WorkLog.timestamp_utc.desc()).limit(20):  # Auto lazy-loaded
                worklog_data = worklog.to_dict()
                worklog_data.update({
                    'artifacts': worklog.get_artifacts(),
                    'context': worklog.get_context()
                })
                worklogs.append(worklog_data)

            return {
                'issue': issue.to_rich_dict(),
                'tasks': tasks,
                'worklogs': worklogs,
                'project': {
                    'project_id': issue.project.project_id,
                    'project_slug': issue.project.project_slug,
                    'absolute_path': issue.project.absolute_path
                }
            }
        except DoesNotExist:
            return None

    @classmethod
    def search_issues(cls, query_text: str, project_id: Optional[str] = None, limit: int = 20) -> List[Dict[str, Any]]:
        """Full-text search using Peewee queries"""
        # Build search conditions
        search_conditions = (
            Issue.title.contains(query_text) |
            Issue.specification.contains(query_text) |
            Issue.planning.contains(query_text) |
            Issue.implementation.contains(query_text)
        )

        query = Issue.select().where(search_conditions)

        if project_id:
            query = query.join(Project).where(Project.project_id == project_id)

        query = query.order_by(Issue.updated_utc.desc()).limit(limit)
        return [issue.to_rich_dict() for issue in query]

    @classmethod
    def create_or_update_issue(cls, issue_data: Dict[str, Any]) -> Dict[str, Any]:
        """Create or update issue using Peewee models"""
        # Find project first
        try:
            project = Project.get(Project.project_id == issue_data['project_id'])
        except DoesNotExist:
            raise ValueError(f"Project {issue_data['project_id']} not found")

        # Prepare JSON fields
        specification = json.dumps({
            'description': issue_data.get('description', ''),
            'acceptance_criteria': issue_data.get('acceptance_criteria', []),
            'technical_approach': issue_data.get('technical_approach', '')
        })

        planning = json.dumps({
            'dependencies': issue_data.get('dependencies', []),
            'stakeholders': issue_data.get('stakeholders', []),
            'estimated_effort': issue_data.get('estimated_effort', ''),
            'complexity': issue_data.get('complexity', 'Medium'),
            'risks': issue_data.get('risks', [])
        })

        implementation = json.dumps({
            'branch_hint': issue_data.get('branch_hint', ''),
            'commit_preamble': issue_data.get('commit_preamble', ''),
            'commit_trailer': issue_data.get('commit_trailer', ''),
            'links': issue_data.get('links', {}),
            'artifacts': issue_data.get('artifacts', [])
        })

        try:
            # Update existing issue
            issue = Issue.get(Issue.key == issue_data['key'])
            issue.title = issue_data.get('title', issue.title)
            issue.type = issue_data.get('type', issue.type)
            issue.status = issue_data.get('status', issue.status)
            issue.priority = issue_data.get('priority', issue.priority)
            issue.module = issue_data.get('module', issue.module)
            issue.owner = issue_data.get('owner', issue.owner)
            issue.specification = specification
            issue.planning = planning
            issue.implementation = implementation
            issue.updated_utc = datetime.utcnow()
            issue.save()
        except DoesNotExist:
            # Create new issue
            issue = Issue.create(
                project=project,
                key=issue_data['key'],
                title=issue_data['title'],
                type=issue_data.get('type', 'feature'),
                status=issue_data.get('status', 'proposed'),
                priority=issue_data.get('priority', 'P3'),
                module=issue_data.get('module'),
                owner=issue_data.get('owner', Config.DEFAULT_OWNER),
                external_id=issue_data.get('external_id'),
                specification=specification,
                planning=planning,
                implementation=implementation,
                created_utc=datetime.utcnow(),
                updated_utc=datetime.utcnow()
            )

        return issue.to_rich_dict()

    @classmethod
    def add_worklog(cls, worklog_data: Dict[str, Any]) -> Dict[str, Any]:
        """Add worklog entry using Peewee models"""
        # Find issue
        try:
            issue = Issue.get(Issue.key == worklog_data['issue_key'])
        except DoesNotExist:
            raise ValueError(f"Issue {worklog_data['issue_key']} not found")

        # Find task (optional)
        task = None
        if worklog_data.get('task_id'):
            try:
                task = Task.get(Task.task_id == worklog_data['task_id'])
            except DoesNotExist:
                pass

        # Create worklog
        worklog = WorkLog.create(
            issue=issue,
            task=task,
            agent=worklog_data['agent'],
            activity=worklog_data['activity'],
            summary=worklog_data['summary'],
            artifacts=json.dumps(worklog_data.get('artifacts', [])),
            context=json.dumps(worklog_data.get('context', {})),
            timestamp_utc=worklog_data.get('timestamp_utc', datetime.utcnow())
        )

        result = worklog.to_dict()
        result.update({
            'artifacts': worklog.get_artifacts(),
            'context': worklog.get_context(),
            'issue_key': issue.key
        })
        return result

    @classmethod
    def create_or_update_task(cls, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """Create or update task using Peewee models"""
        # Find issue
        try:
            issue = Issue.get(Issue.key == task_data['issue_key'])
        except DoesNotExist:
            raise ValueError(f"Issue {task_data['issue_key']} not found")

        # Prepare details JSON
        details = json.dumps({
            'checklist': task_data.get('checklist', []),
            'notes': task_data.get('notes', ''),
            'time_estimate': task_data.get('time_estimate', '')
        })

        try:
            # Update existing task
            task = Task.get(Task.task_id == task_data['task_id'])
            task.title = task_data.get('title', task.title)
            task.status = task_data.get('status', task.status)
            task.assignee = task_data.get('assignee', task.assignee)
            task.details = details
            task.updated_utc = datetime.utcnow()
            task.save()
        except DoesNotExist:
            # Create new task
            task = Task.create(
                issue=issue,
                task_id=task_data['task_id'],
                title=task_data['title'],
                status=task_data.get('status', 'todo'),
                assignee=task_data.get('assignee'),
                details=details,
                created_utc=datetime.utcnow(),
                updated_utc=datetime.utcnow()
            )

        result = task.to_dict()
        result.update({
            'checklist': task.checklist,
            'notes': task.notes,
            'issue_key': issue.key
        })
        return result

    @classmethod
    def get_my_queue(cls, owner: str, limit: int = 20) -> List[Dict[str, Any]]:
        """Get work queue for owner using Peewee query"""
        issues = (Issue.select()
                 .where((Issue.owner == owner) &
                        (Issue.status.in_(['proposed', 'in_progress', 'review'])))
                 .order_by(Issue.priority.asc(), Issue.updated_utc.desc())
                 .limit(limit))

        return [issue.to_rich_dict() for issue in issues]

    @classmethod
    def get_blocked_issues(cls, project_id: Optional[str] = None) -> List[Dict[str, Any]]:
        """Get blocked issues using Peewee query"""
        query = Issue.select().where(Issue.status == 'blocked')

        if project_id:
            query = query.join(Project).where(Project.project_id == project_id)

        return [issue.to_rich_dict() for issue in query.order_by(Issue.updated_utc.desc())]

    @classmethod
    def get_recent_worklogs(cls, issue_key: Optional[str] = None,
                           project_id: Optional[str] = None, limit: int = 20) -> List[Dict[str, Any]]:
        """Get recent worklogs using Peewee relationships"""
        query = WorkLog.select()

        if issue_key:
            query = query.join(Issue).where(Issue.key == issue_key)
        elif project_id:
            query = query.join(Issue).join(Project).where(Project.project_id == project_id)

        worklogs = query.order_by(WorkLog.timestamp_utc.desc()).limit(limit)

        result = []
        for worklog in worklogs:
            data = worklog.to_dict()
            data.update({
                'artifacts': worklog.get_artifacts(),
                'context': worklog.get_context(),
                'issue_key': worklog.issue.key
            })
            result.append(data)
        return result

    @classmethod
    def update_issue_planning_estimate(cls, issue, effort: str, complexity: Optional[str], reasoning: Optional[str]):
        """Update issue planning with estimates"""
        planning = _get_issue_field_json(issue, 'planning')
        planning["estimated_effort"] = effort
        if complexity:
            planning["complexity"] = complexity
        if reasoning:
            notes = planning.get("estimate_notes", [])
            notes.append({
                "timestamp_utc": datetime.utcnow().isoformat() + "Z",
                "reasoning": reasoning
            })
            planning["estimate_notes"] = notes
        issue.planning = json.dumps(planning)
        issue.updated_utc = datetime.utcnow()
        issue.save()
        return issue

    @classmethod
    def create_task(cls, issue, title: str, assignee: Optional[str], details: Optional[Dict[str, Any]]):
        """Create task with auto-generated ID"""
        existing = Task.select(fn.COUNT()).where(Task.issue == issue).scalar() or 0
        task_id = f"{issue.key}-T{existing + 1}"
        t = Task.create(
            issue=issue,
            task_id=task_id,
            title=title,
            status="todo",
            assignee=assignee,
            details=json.dumps(details or {}),
            created_utc=datetime.utcnow(),
            updated_utc=datetime.utcnow(),
        )
        return t

    @classmethod
    def get_task(cls, task_id: str) -> Optional[Task]:
        """Get task by ID"""
        try:
            return Task.get(Task.task_id == task_id)
        except DoesNotExist:
            return None

    @classmethod
    def update_task(cls, task, title=None, status=None, assignee=None, details=None):
        """Update task fields"""
        if title is not None:
            task.title = title
        if status is not None:
            task.status = status
        if assignee is not None:
            task.assignee = assignee
        if details is not None:
            task.details = json.dumps(details)
        task.updated_utc = datetime.utcnow()
        task.save()
        return task

    @classmethod
    def append_worklog(cls, issue, agent: str, activity: str, summary: str,
                      artifacts: Optional[List[Dict[str, Any]]], context: Optional[Dict[str, Any]],
                      task=None):
        """Add worklog entry"""
        wl = WorkLog.create(
            issue=issue,
            task=task,
            agent=agent,
            timestamp_utc=datetime.utcnow(),
            activity=activity,
            summary=summary,
            artifacts=json.dumps(artifacts or []),
            context=json.dumps(context or {}),
        )
        return wl

    @classmethod
    def project_metrics(cls, project):
        """Calculate project metrics"""
        issues = list(project.issues)
        status_counts = {}
        priority_counts = {}
        module_counts = {}
        for i in issues:
            status_counts[i.status] = status_counts.get(i.status, 0) + 1
            priority_counts[i.priority] = priority_counts.get(i.priority, 0) + 1
            if i.module:
                module_counts[i.module] = module_counts.get(i.module, 0) + 1

        recent_work = (WorkLog
                      .select()
                      .join(Issue)
                      .where(Issue.project == project)
                      .order_by(WorkLog.timestamp_utc.desc())
                      .limit(20))
        recent = []
        for w in recent_work:
            recent.append({
                "issue_key": w.issue.key,
                "task_id": w.task.task_id if w.task else None,
                "agent": w.agent,
                "activity": w.activity,
                "summary": w.summary,
                "timestamp_utc": w.timestamp_utc.isoformat() + "Z",
            })

        return {
            "counts": {
                "total": len(issues),
                "by_status": status_counts,
                "by_priority": priority_counts,
                "by_module": module_counts,
            },
            "recent_work": recent,
        }

    @classmethod
    def owner_capacity(cls, project):
        """Get capacity by owner"""
        rows = (Issue
               .select(Issue.owner, fn.COUNT(Issue.id).alias('count'))
               .where(Issue.project == project)
               .group_by(Issue.owner))
        result = []
        for r in rows:
            result.append({"owner": r.owner, "issue_count": r.count})
        return result

    @classmethod
    def generate_issue_key(cls, project_slug: str) -> str:
        """Generate unique issue key with proper collision handling"""
        # Get max issue number for this project to avoid races
        prefix = project_slug.upper()[:4].replace('-', '')
        if not prefix:
            prefix = "PROJ"

        # Use date-based format
        date_part = datetime.now().strftime("%Y%m")

        # Find max number for this month to avoid collisions
        pattern = f"{prefix}-{date_part}-%"
        existing = (Issue.select()
                   .where(Issue.key.startswith(f"{prefix}-{date_part}-"))
                   .order_by(Issue.key.desc())
                   .limit(1))

        max_num = 0
        for issue in existing:
            try:
                parts = issue.key.split('-')
                if len(parts) >= 3:
                    max_num = max(max_num, int(parts[2]))
            except (ValueError, IndexError):
                pass

        return f"{prefix}-{date_part}-{max_num + 1:03d}"

# Context manager for database operations
class DatabaseSession:
    """Context manager for database operations"""
    def __enter__(self):
        PMDatabase.connect()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        PMDatabase.close()