#!/usr/bin/env python3
"""
LLM-Native Project Management MCP Server
Production-ready implementation with all fixes applied
"""
import os
import sys
import asyncio
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent))

try:
    from mcp.server.fastmcp import FastMCP
except ImportError:
    print("❌ Error: MCP library not installed. Run 'pip install mcp' first.")
    sys.exit(1)

from config import Config
from database import PMDatabase, DatabaseSession
from models import *
from utils import *
from git_integration import git_status, git_current_branch, git_push_current

# Initialize MCP server
mcp = FastMCP("pm-server")

# =============== Helper Functions ===============

def get_default_project_id() -> Optional[str]:
    """Get default project ID from config or first available"""
    if Config.DEFAULT_PROJECT_ID:
        return Config.DEFAULT_PROJECT_ID

    try:
        with DatabaseSession():
            projects = PMDatabase.get_all_projects()
            if projects:
                return projects[0]['project_id']
    except Exception:
        pass
    return None

# Use standardized response functions from utils
# standard_response replaced with ok() and err() functions

# =============== Discovery Tools ===============

@mcp.tool()
def pm_docs(input: PMDocsInput) -> Dict[str, Any]:
    """
    Get comprehensive PM system documentation and workflow guidance.
    This tool provides the LLM with understanding of available commands,
    workflows, and best practices for project management.
    """
    docs = {
        "overview": """# LLM-Native Project Management System

This PM system is designed for LLM agents as first-class citizens, providing:
- Rich context and documentation in every issue
- Git integration with automatic branch and commit management
- Comprehensive work tracking and analytics
- Workflow automation and intelligent planning

## Core Concepts
- **Issues**: Rich, documented work items with LLM-generated specs
- **Projects**: Collections of issues with modules and metadata
- **Work Logs**: Detailed activity tracking with artifacts
- **Git Integration**: Automatic branch creation and commit formatting

## Available Tool Categories
1. **Discovery**: pm_docs, pm_status, pm_list_issues, pm_get_issue, pm_search_issues
2. **Planning**: pm_create_issue, pm_update_issue, pm_estimate, pm_refine_issue
3. **Execution**: pm_start_work, pm_log_work, pm_update_status, pm_create_task
4. **Git**: pm_git_status, pm_create_branch, pm_commit, pm_push_branch
5. **Analytics**: pm_project_dashboard, pm_my_queue, pm_blocked_issues
6. **Workflow**: pm_daily_standup, pm_weekly_report, pm_capacity_planning""",

        "commands": """# PM Command Reference

## Discovery Commands
- `pm_docs`: Get documentation (this command)
- `pm_status`: Project status overview with metrics
- `pm_list_issues`: List and filter issues with sorting
- `pm_get_issue`: Get detailed issue with context
- `pm_list_projects`: List all available projects
- `pm_search_issues`: Full-text search across all content

## Planning Commands
- `pm_create_issue`: Create comprehensive issue with rich specs
- `pm_update_issue`: Update issue details and content
- `pm_estimate`: Add effort and complexity estimates with reasoning
- `pm_refine_issue`: Iteratively refine requirements and approach

## Execution Commands
- `pm_start_work`: Begin work on issue (status + optional branch)
- `pm_log_work`: Log development activity with artifacts
- `pm_update_status`: Change issue status with workflow validation
- `pm_create_task`: Break issue into manageable tasks

## Git Integration
- `pm_git_status`: Enhanced git status with issue context
- `pm_create_branch`: Create feature branch with conventions
- `pm_commit`: Commit with PM trailers and formatting
- `pm_push_branch`: Push and optionally create PR

## Analytics & Reporting
- `pm_project_dashboard`: Comprehensive project health metrics
- `pm_my_queue`: Personal work queue with intelligent prioritization
- `pm_blocked_issues`: Find and analyze blocked work
- `pm_daily_standup`: Generate daily standup report
- `pm_weekly_report`: Weekly progress and velocity report""",

        "workflow": """# Typical LLM Agent Workflow

## 1. Fresh Session Startup
```
pm_docs                    # Understand the system capabilities
pm_status                  # Get project health overview
pm_my_queue               # Get prioritized work queue
pm_blocked_issues         # Check for unblocking opportunities
```

## 2. Creating New Feature
```
pm_create_issue --type feature --title "Add user authentication"
  --description "Comprehensive technical specification..."
  --priority P2 --module backend

pm_estimate --effort "3-5 days" --complexity High
  --reasoning "JWT implementation + database changes + testing"

pm_refine_issue --aspect technical
  --suggestions "Consider OAuth integration for future"
```

## 3. Starting Implementation
```
pm_start_work --issue-key PROJ-001    # Status → in_progress + branch
pm_git_status                         # Verify git state
pm_create_branch                      # Create if not auto-created
```

## 4. Development Loop
```
pm_log_work --activity code --summary "Implemented JWT middleware"
  --artifacts '[{"type":"file","path":"src/auth.py"}]'
  --time-spent "2h"

pm_commit --message "feat: add JWT authentication middleware"
# Auto-formatted: [pm PROJ-001] feat: add JWT middleware\n\nPM: PROJ-001

pm_create_task --title "Add integration tests"
  --checklist '["Write auth tests","Test token validation"]'
```

## 5. Completion
```
pm_update_status --status review
  --notes "Implementation complete, ready for security review"

pm_push_branch --create-pr
  --reviewers '["security-team","backend-team"]'

pm_log_work --activity review
  --summary "Created PR and requested reviews"
```""",

        "troubleshooting": """# Troubleshooting Guide

## Common Issues

### Database Connection
- Ensure `PM_DATABASE_PATH` points to valid SQLite file
- Run Jira-lite migration if database doesn't exist
- Check file permissions on database file

### Git Operations
- Ensure you're in a valid git repository
- Check git identity is configured
- Verify remote branches exist before pulling

### Issue Creation
- Ensure project exists and is registered
- Use descriptive titles and detailed descriptions
- Include acceptance criteria for better tracking

## Environment Variables
- `PM_DATABASE_PATH`: Path to SQLite database (required)
- `PM_DEFAULT_PROJECT_ID`: Default project to use
- `PM_DEFAULT_OWNER`: Default issue owner
- `GIT_USER_NAME`: Git commit author name
- `GIT_USER_EMAIL`: Git commit author email

## Commands for Debug
- `pm_status --verbose`: Detailed project health
- `pm_list_projects`: See all available projects
- `pm_git_status`: Check git repository state
- `pm_blocked_issues`: Find systematic blockers"""
    }

    section = input.section or "overview"
    content = docs.get(section, docs["overview"])

    return ok(f"Documentation: {section}", {
        "content": content,
        "section": section,
        "available_sections": list(docs.keys())
    }, hints=["Use --section parameter to get specific documentation sections"])

@mcp.tool()
def pm_status(input: PMStatusInput) -> Dict[str, Any]:
    """
    Get comprehensive project status including issue counts, velocity metrics,
    and current work distribution. Essential for understanding project health.
    """
    project_id = input.project_id or get_default_project_id()
    if not project_id:
        return err("No project specified and no default available",
                  hints=["Use pm_list_projects to see available projects", "Set PM_DEFAULT_PROJECT_ID environment variable"])

    try:
        with DatabaseSession():
            project = PMDatabase.get_project(project_id)
            if not project:
                return standard_response(
                    success=False,
                    message=f"Project {project_id} not found",
                    hints=["Use pm_list_projects to see available projects"]
                )

            # Get all issues for project
            issues = PMDatabase.get_issues(project_id=project_id, limit=1000)

            # Calculate statistics
            status_counts = {}
            priority_counts = {}
            module_counts = {}

            for issue in issues:
                status_counts[issue['status']] = status_counts.get(issue['status'], 0) + 1
                priority_counts[issue['priority']] = priority_counts.get(issue['priority'], 0) + 1
                if issue['module']:
                    module_counts[issue['module']] = module_counts.get(issue['module'], 0) + 1

            # Calculate velocity if requested
            velocity_data = {}
            if input.include_velocity:
                completed_issues = [i for i in issues if i['status'] == 'done']
                velocity_data = calculate_velocity(completed_issues, timeframe_days=7)

            result_data = {
                "project": {
                    "id": project['project_id'],
                    "name": project['project_slug'],
                    "path": project['absolute_path'],
                    "modules": len(project.get('submodules', []))
                },
                "summary": {
                    "total_issues": len(issues),
                    "open_issues": len([i for i in issues if i['status'] not in ['done', 'canceled']]),
                    "in_progress": status_counts.get('in_progress', 0),
                    "blocked": status_counts.get('blocked', 0)
                },
                "distributions": {
                    "by_status": status_counts,
                    "by_priority": priority_counts
                }
            }

            if input.verbose:
                result_data["distributions"]["by_module"] = module_counts
                result_data["recent_activity"] = [
                    {
                        "key": i['key'],
                        "title": i['title'],
                        "status": i['status'],
                        "updated": i['updated_utc']
                    }
                    for i in sorted(issues, key=lambda x: x['updated_utc'], reverse=True)[:5]
                ]

            if velocity_data:
                result_data["velocity"] = velocity_data

            # Generate hints
            hints = []
            if status_counts.get('blocked', 0) > 0:
                hints.append(f"pm_blocked_issues - {status_counts['blocked']} issues are blocked")
            if status_counts.get('in_progress', 0) > 5:
                hints.append("High WIP - consider completing issues before starting new ones")
            if not issues:
                hints.append("pm_create_issue - No issues found, create your first issue")

            return standard_response(
                success=True,
                message=f"Project status for {project['project_slug']}",
                data=result_data,
                hints=hints
            )

    except Exception as e:
        return standard_response(
            success=False,
            message=f"Failed to get project status: {type(e).__name__}",
            hints=["Check database connectivity", "Verify project exists"]
        )

@mcp.tool()
def pm_list_issues(input: ListIssuesInput) -> Dict[str, Any]:
    """
    List and filter project issues with comprehensive details.
    Returns structured issue data suitable for analysis and planning.
    """
    project_id = input.project_id or get_default_project_id()

    try:
        with DatabaseSession():
            issues = PMDatabase.get_issues(
                project_id=project_id,
                status=input.status,
                priority=input.priority,
                module=input.module,
                owner=input.owner,
                limit=input.limit
            )

            # Apply additional filtering by type if specified
            if input.type:
                issues = [i for i in issues if i.get('type') == input.type]

            # Sort based on input
            if input.sort_by == 'priority':
                priority_order = {'P1': 1, 'P2': 2, 'P3': 3, 'P4': 4, 'P5': 5}
                issues.sort(key=lambda i: priority_order.get(i['priority'], 6))
            elif input.sort_by == 'created':
                issues.sort(key=lambda i: i['created_utc'])
            elif input.sort_by == 'status':
                status_order = {'in_progress': 1, 'review': 2, 'proposed': 3, 'blocked': 4, 'done': 5}
                issues.sort(key=lambda i: status_order.get(i['status'], 6))
            # 'updated' is already the default sort

            # Generate helpful hints
            hints = []
            if len(issues) == input.limit:
                hints.append(f"Results limited to {input.limit} - use filters to narrow down")
            if not issues and not any([input.status, input.priority, input.module, input.owner]):
                hints.append("No issues found - try pm_create_issue to add some work")
            if issues:
                hints.append(f"Use pm_get_issue with any key like '{issues[0]['key']}' for full details")

            return standard_response(
                success=True,
                message=f"Found {len(issues)} issues",
                data={
                    "issues": issues,
                    "count": len(issues),
                    "filters_applied": {
                        "project_id": project_id,
                        "status": input.status,
                        "priority": input.priority,
                        "module": input.module,
                        "owner": input.owner,
                        "type": input.type
                    },
                    "sort_by": input.sort_by
                },
                hints=hints
            )

    except Exception as e:
        return standard_response(
            success=False,
            message=f"Failed to list issues: {type(e).__name__}",
            hints=["Check database connectivity", "Verify project exists"]
        )

@mcp.tool()
def pm_get_issue(input: GetIssueInput) -> Dict[str, Any]:
    """
    Get comprehensive issue details including specifications, tasks, and work history.
    Essential for understanding issue context before starting work.
    FIXED: Uses Peewee models instead of raw SQL queries.
    """
    try:
        with DatabaseSession():
            if input.include_tasks or input.include_worklogs:
                # Get issue with all relations using Peewee models
                issue_data = PMDatabase.get_issue_with_relations(input.issue_key)
                if not issue_data:
                    return standard_response(
                        success=False,
                        message=f"Issue {input.issue_key} not found",
                        hints=["Use pm_search_issues to find issues", "Check issue key format"]
                    )

                result_data = {
                    "issue": issue_data['issue']
                }

                if input.include_tasks:
                    result_data["tasks"] = issue_data['tasks']

                if input.include_worklogs:
                    result_data["worklogs"] = issue_data['worklogs']

                # Add project info
                result_data["project"] = issue_data['project']

            else:
                # Get just the issue
                issue = PMDatabase.get_issue(input.issue_key)
                if not issue:
                    return standard_response(
                        success=False,
                        message=f"Issue {input.issue_key} not found"
                    )
                result_data = {"issue": issue}

            # Add dependency analysis if requested
            if input.include_dependencies:
                all_issues = PMDatabase.get_issues(project_id=result_data['issue']['project_id'], limit=1000)
                deps = analyze_dependencies(result_data['issue'], all_issues)
                result_data["dependencies"] = deps

            # Generate contextual next steps
            issue = result_data['issue']
            hints = []
            if issue['status'] == 'proposed':
                hints.extend([
                    f"pm_estimate --issue-key {issue['key']} to add effort estimates",
                    f"pm_refine_issue --issue-key {issue['key']} to refine requirements",
                    f"pm_start_work --issue-key {issue['key']} to begin implementation"
                ])
            elif issue['status'] == 'in_progress':
                hints.extend([
                    f"pm_log_work --issue-key {issue['key']} to track current activity",
                    f"pm_create_task --issue-key {issue['key']} to break down work",
                    f"pm_commit --issue-key {issue['key']} to save changes"
                ])
            elif issue['status'] == 'review':
                hints.extend([
                    f"pm_push_branch --issue-key {issue['key']} --create-pr to create pull request",
                    f"pm_update_status --issue-key {issue['key']} --status done when approved"
                ])

            return standard_response(
                success=True,
                message=f"Issue details for {input.issue_key}",
                data=result_data,
                hints=hints
            )

    except Exception as e:
        return standard_response(
            success=False,
            message=f"Failed to get issue: {type(e).__name__}",
            hints=["Check database connectivity", "Verify issue key format"]
        )

@mcp.tool()
def pm_search_issues(input: SearchIssuesInput) -> Dict[str, Any]:
    """
    Full-text search across all issue content.
    Searches titles, descriptions, and all rich content fields.
    """
    try:
        with DatabaseSession():
            issues = PMDatabase.search_issues(
                query_text=input.query,
                project_id=input.project_id,
                limit=input.limit
            )

            # If not including content, strip heavy fields for performance
            if not input.include_content:
                for issue in issues:
                    issue.pop('description', None)
                    issue.pop('technical_approach', None)

            return standard_response(
                success=True,
                message=f"Found {len(issues)} issues matching '{input.query}'",
                data={
                    "query": input.query,
                    "project_id": input.project_id,
                    "results": issues,
                    "total_matches": len(issues),
                    "include_content": input.include_content
                },
                hints=[
                    f"Use pm_get_issue --issue-key {issues[0]['key']} for full details" if issues else "Try broader search terms",
                    "Use --include-content true to see full descriptions in results"
                ]
            )

    except Exception as e:
        return standard_response(
            success=False,
            message=f"Search failed: {type(e).__name__}",
            hints=["Check database connectivity", "Try simpler search terms"]
        )

@mcp.tool()
def pm_list_projects() -> Dict[str, Any]:
    """
    List all available projects in the system.
    Shows project metadata and basic statistics.
    """
    try:
        with DatabaseSession():
            projects = PMDatabase.get_all_projects()

            # Enhance with issue counts
            for project in projects:
                issues = PMDatabase.get_issues(project_id=project['project_id'], limit=1000)
                project['issue_count'] = len(issues)
                project['active_issues'] = len([i for i in issues if i['status'] not in ['done', 'canceled']])

            hints = []
            if projects:
                hints.append(f"Use pm_status --project-id {projects[0]['project_id']} for detailed project health")
                hints.append("Set PM_DEFAULT_PROJECT_ID environment variable to avoid specifying project each time")
            else:
                hints.append("No projects found - register a project with the Jira-lite web UI first")

            return standard_response(
                success=True,
                message=f"Found {len(projects)} projects",
                data={
                    "projects": projects,
                    "count": len(projects),
                    "default_project": get_default_project_id()
                },
                hints=hints
            )

    except Exception as e:
        return standard_response(
            success=False,
            message=f"Failed to list projects: {type(e).__name__}",
            hints=["Check database connectivity", "Ensure Jira-lite database exists"]
        )

# =============== Planning Tools ===============

@mcp.tool()
def pm_create_issue(input: CreateIssueInput) -> Dict[str, Any]:
    """
    Create a comprehensive issue with rich LLM-generated documentation.
    This is the primary tool for capturing work with full context and specifications.
    """
    project_id = input.project_id or get_default_project_id()
    if not project_id:
        return standard_response(
            success=False,
            message="No project specified and no default available",
            hints=["Use pm_list_projects to see available projects"]
        )

    try:
        with DatabaseSession():
            # Validate project exists
            project = PMDatabase.get_project(project_id)
            if not project:
                return standard_response(
                    success=False,
                    message=f"Project {project_id} not found"
                )

            # Generate unique issue key with collision handling
            existing_issues = PMDatabase.get_issues(project_id=project_id, limit=1000)
            issue_key = PMDatabase.generate_issue_key(project['project_slug'])

            # Generate git integration hints
            branch_hint = generate_branch_name(issue_key, input.type, input.title)
            commit_preamble = f"[pm {issue_key}]"
            commit_trailer = f"PM: {issue_key}"

            # Create comprehensive issue data
            issue_data = {
                'project_id': project_id,
                'key': issue_key,
                'title': input.title,
                'type': input.type,
                'status': 'proposed',
                'priority': input.priority,
                'module': input.module,
                'owner': input.owner or Config.DEFAULT_OWNER,
                'description': input.description,
                'acceptance_criteria': input.acceptance_criteria,
                'technical_approach': input.technical_approach or "",
                'dependencies': input.dependencies,
                'estimated_effort': input.estimated_effort,
                'complexity': input.complexity,
                'stakeholders': input.stakeholders,
                'branch_hint': branch_hint,
                'commit_preamble': commit_preamble,
                'commit_trailer': commit_trailer,
                'links': {
                    'repo': f"file://{project['absolute_path']}",
                    'branch': branch_hint
                }
            }

            created_issue = PMDatabase.create_or_update_issue(issue_data)

            return standard_response(
                success=True,
                message=f"Created issue {issue_key}: {input.title}",
                data={
                    "issue": created_issue,
                    "git_hints": {
                        "branch": branch_hint,
                        "commit_preamble": commit_preamble,
                        "commit_trailer": commit_trailer
                    }
                },
                hints=[
                    f"pm_estimate --issue-key {issue_key} to add effort estimates",
                    f"pm_start_work --issue-key {issue_key} to begin implementation",
                    f"pm_refine_issue --issue-key {issue_key} to enhance requirements"
                ]
            )

    except Exception as e:
        return standard_response(
            success=False,
            message=f"Failed to create issue: {type(e).__name__}",
            hints=["Check project exists", "Verify all required fields"]
        )

@mcp.tool()
def pm_start_work(input: StartWorkInput) -> Dict[str, Any]:
    """
    Start work on an issue - updates status, optionally creates branch.
    This is the primary entry point for beginning implementation.
    """
    try:
        with DatabaseSession():
            issue = PMDatabase.get_issue(input.issue_key)
            if not issue:
                return standard_response(
                    success=False,
                    message=f"Issue {input.issue_key} not found"
                )

            # Validate dependencies if requested
            if input.validate_dependencies:
                all_issues = PMDatabase.get_issues(project_id=issue['project_id'], limit=1000)
                deps = analyze_dependencies(issue, all_issues)
                if not deps['ready_to_work']:
                    pending = [d['key'] for d in deps['depends_on'] if not d['ready']]
                    return standard_response(
                        success=False,
                        message=f"Cannot start work - dependencies not completed: {', '.join(pending)}",
                        hints=[f"Complete dependencies first: {', '.join(pending)}"]
                    )

            # Update status to in_progress
            update_data = issue.copy()
            old_status = issue['status']
            update_data['status'] = 'in_progress'
            updated_issue = PMDatabase.create_or_update_issue(update_data)

            # Log work start
            PMDatabase.add_worklog({
                'issue_key': input.issue_key,
                'agent': Config.DEFAULT_OWNER,
                'activity': 'planning',
                'summary': f"Started work on {input.issue_key}: {issue['title']}",
                'context': {
                    'previous_status': old_status,
                    'notes': input.notes or "Beginning implementation"
                }
            })

            result_data = {
                "issue": updated_issue,
                "status_changed": f"{old_status} → in_progress"
            }

            hints = [
                f"pm_log_work --issue-key {input.issue_key} to track progress",
                f"pm_create_task --issue-key {input.issue_key} to break down work"
            ]

            # Handle branch creation if requested
            if input.create_branch:
                project = PMDatabase.get_project(issue['project_id'])
                if project:
                    try:
                        branch_name = issue.get('branch_hint') or generate_branch_name(
                            input.issue_key, issue['type'], issue['title']
                        )

                        project_path = Path(project['absolute_path'])

                        # Ensure git setup
                        if not asyncio.run(ensure_project_git_setup(project_path)):
                            result_data['branch_warning'] = 'Git setup incomplete - manual branch creation recommended'
                        else:
                            git_result = run_git_command_sync(['checkout', '-b', branch_name], cwd=project_path)
                            if git_result['success']:
                                result_data['branch_created'] = branch_name
                                sanitized = sanitize_git_output(git_result['output'], git_result.get('error', ''))
                                result_data['git_output'] = sanitized['output']
                                hints.append(f"Branch '{branch_name}' created and checked out")
                            else:
                                result_data['branch_error'] = git_result['error']
                                hints.append("Branch creation failed - create manually if needed")
                    except Exception:
                        result_data['branch_error'] = 'Branch creation failed'

            return standard_response(
                success=True,
                message=f"Started work on {input.issue_key}",
                data=result_data,
                hints=hints
            )

    except Exception as e:
        return standard_response(
            success=False,
            message=f"Failed to start work: {type(e).__name__}",
            hints=["Check issue exists", "Verify issue is in startable state"]
        )

@mcp.tool()
def pm_log_work(input: LogWorkInput) -> Dict[str, Any]:
    """
    Log development activity with artifacts and context.
    Essential for tracking progress and building project knowledge.
    """
    try:
        with DatabaseSession():
            issue = PMDatabase.get_issue(input.issue_key)
            if not issue:
                return standard_response(
                    success=False,
                    message=f"Issue {input.issue_key} not found"
                )

            # Build work log data
            context_data = {}
            if input.time_spent:
                context_data['time_spent'] = input.time_spent
                context_data['hours_logged'] = parse_duration(input.time_spent)
            if input.blockers:
                context_data['blockers'] = input.blockers
            if input.decisions:
                context_data['decisions'] = input.decisions

            worklog_data = {
                'issue_key': input.issue_key,
                'agent': Config.DEFAULT_OWNER,
                'activity': input.activity,
                'summary': input.summary,
                'artifacts': input.artifacts,
                'context': context_data
            }

            if input.task_id:
                worklog_data['task_id'] = input.task_id

            worklog = PMDatabase.add_worklog(worklog_data)

            # Calculate time for response
            hours_spent = parse_duration(input.time_spent) if input.time_spent else 0

            return standard_response(
                success=True,
                message=f"Logged {input.activity} work on {input.issue_key}",
                data={
                    "worklog": worklog,
                    "time_logged": input.time_spent,
                    "hours_logged": hours_spent,
                    "artifacts_count": len(input.artifacts)
                },
                hints=[
                    f"pm_commit --issue-key {input.issue_key} to save code changes",
                    f"pm_update_status --issue-key {input.issue_key} to change status when ready"
                ]
            )

    except Exception as e:
        return standard_response(
            success=False,
            message=f"Failed to log work: {type(e).__name__}",
            hints=["Check issue exists", "Verify time format (e.g., '2h', '30m')"]
        )

# =============== Git Integration Tools ===============

@mcp.tool()
def pm_create_branch(input: CreateBranchInput) -> Dict[str, Any]:
    """
    Create a git branch for an issue following naming conventions.
    Automatically configures branch tracking and updates issue metadata.
    FIXED: Proper error handling and security.
    """
    try:
        with DatabaseSession():
            issue = PMDatabase.get_issue(input.issue_key)
            if not issue:
                return standard_response(
                    success=False,
                    message=f"Issue {input.issue_key} not found"
                )

            project = PMDatabase.get_project(issue['project_id'])
            if not project:
                return standard_response(
                    success=False,
                    message=f"Project {issue['project_id']} not found"
                )

            # Rate limiting check
            if not git_rate_limiter.can_proceed():
                return standard_response(
                    success=False,
                    message="Rate limit exceeded for git operations",
                    hints=["Wait a moment before retrying git operations"]
                )

            # Generate or validate branch name
            branch_name = input.branch_name or issue.get('branch_hint') or generate_branch_name(
                input.issue_key, issue['type'], issue['title']
            )

            if not validate_branch_name(branch_name):
                return standard_response(
                    success=False,
                    message=f"Invalid branch name: {branch_name}",
                    hints=["Use alphanumeric characters and hyphens only"]
                )

            project_path = Path(project['absolute_path'])

            # Ensure git setup
            setup_success = asyncio.run(ensure_project_git_setup(project_path))
            if not setup_success:
                return standard_response(
                    success=False,
                    message="Git setup failed - ensure repository is properly initialized",
                    hints=["Check if directory is a git repository", "Verify git is installed"]
                )

            # Checkout base branch safely
            git_result = run_git_command_sync(['checkout', input.base_branch], cwd=project_path)
            if not git_result['success']:
                return standard_response(
                    success=False,
                    message=f"Failed to checkout base branch {input.base_branch}",
                    data={"git_error": git_result['error']},
                    hints=[f"Ensure branch '{input.base_branch}' exists"]
                )

            # Pull latest changes (handle gracefully if no remote)
            pull_result = run_git_command_sync(['pull'], cwd=project_path)
            # Don't fail on pull errors - might be offline or no remote

            # Create new branch
            git_result = run_git_command_sync(['checkout', '-b', branch_name], cwd=project_path)

            if git_result['success']:
                # Update issue with branch info
                update_data = issue.copy()
                update_data['branch_hint'] = branch_name
                PMDatabase.create_or_update_issue(update_data)

                # Log branch creation
                PMDatabase.add_worklog({
                    'issue_key': input.issue_key,
                    'agent': Config.DEFAULT_OWNER,
                    'activity': 'code',
                    'summary': f"Created branch: {branch_name}",
                    'artifacts': [
                        {
                            'type': 'branch',
                            'name': branch_name,
                            'base': input.base_branch
                        }
                    ]
                })

                sanitized = sanitize_git_output(git_result['output'], git_result.get('error', ''))

                return standard_response(
                    success=True,
                    message=f"Created and checked out branch: {branch_name}",
                    data={
                        "branch": branch_name,
                        "base_branch": input.base_branch,
                        "git_output": sanitized['output']
                    },
                    hints=[
                        f"pm_log_work --issue-key {input.issue_key} to start tracking work",
                        f"pm_commit --issue-key {input.issue_key} to save changes"
                    ]
                )
            else:
                sanitized = sanitize_git_output(git_result.get('output', ''), git_result.get('error', ''))
                return standard_response(
                    success=False,
                    message="Failed to create branch",
                    data={"git_error": sanitized['error']},
                    hints=["Check if branch already exists", "Ensure working directory is clean"]
                )

    except Exception as e:
        return standard_response(
            success=False,
            message=f"Branch creation failed: {type(e).__name__}",
            hints=["Check git repository status", "Verify project path exists"]
        )

@mcp.tool()
def pm_commit(input: CommitInput) -> Dict[str, Any]:
    """
    Create a git commit with PM trailers and issue context.
    Automatically formats commit messages with conventional commit style.
    FIXED: Proper regex handling and async safety.
    """
    try:
        with DatabaseSession():
            issue = PMDatabase.get_issue(input.issue_key)
            if not issue:
                return standard_response(
                    success=False,
                    message=f"Issue {input.issue_key} not found"
                )

            project = PMDatabase.get_project(issue['project_id'])
            if not project:
                return standard_response(
                    success=False,
                    message=f"Project {issue['project_id']} not found"
                )

            # Rate limiting
            if not git_rate_limiter.can_proceed():
                return standard_response(
                    success=False,
                    message="Rate limit exceeded for git operations"
                )

            project_path = Path(project['absolute_path'])

            # Ensure git identity is set
            setup_success = asyncio.run(ensure_project_git_setup(project_path))
            if not setup_success:
                return standard_response(
                    success=False,
                    message="Git identity setup failed"
                )

            # Format commit message with FIXED regex
            commit_message = format_commit_message(input.issue_key, input.message)

            # Stage files if specified
            if input.files:
                for file in input.files:
                    git_result = run_git_command_sync(['add', file], cwd=project_path)
                    if not git_result['success']:
                        return standard_response(
                            success=False,
                            message=f"Failed to stage file: {file}",
                            data={"git_error": git_result['error']}
                        )
            else:
                # Stage all changes
                git_result = run_git_command_sync(['add', '-A'], cwd=project_path)

            # Create commit
            commit_args = ['commit', '-m', commit_message]
            if input.amend:
                commit_args.append('--amend')

            git_result = run_git_command_sync(commit_args, cwd=project_path)

            if git_result['success']:
                # Get commit SHA
                sha_result = run_git_command_sync(['rev-parse', 'HEAD'], cwd=project_path)
                commit_sha = sha_result['output'][:7] if sha_result['success'] else 'unknown'

                # Log commit as work activity if requested
                if input.log_work:
                    PMDatabase.add_worklog({
                        'issue_key': input.issue_key,
                        'agent': Config.DEFAULT_OWNER,
                        'activity': 'code',
                        'summary': f"Committed: {input.message}",
                        'artifacts': [
                            {
                                'type': 'commit',
                                'sha': commit_sha,
                                'message': commit_message,
                                'files': input.files or []
                            }
                        ]
                    })

                sanitized = sanitize_git_output(git_result['output'], git_result.get('error', ''))

                return standard_response(
                    success=True,
                    message="Commit created successfully",
                    data={
                        "commit_sha": commit_sha,
                        "commit_message": commit_message,
                        "git_output": sanitized['output']
                    },
                    hints=[
                        f"pm_push_branch --issue-key {input.issue_key} to push changes",
                        f"pm_log_work --issue-key {input.issue_key} to continue tracking work"
                    ]
                )
            else:
                sanitized = sanitize_git_output(git_result.get('output', ''), git_result.get('error', ''))
                return standard_response(
                    success=False,
                    message="Failed to create commit",
                    data={"git_error": sanitized['error']},
                    hints=["Check if there are changes to commit", "Verify git repository state"]
                )

    except Exception as e:
        return standard_response(
            success=False,
            message=f"Commit failed: {type(e).__name__}",
            hints=["Check git repository status", "Verify working directory"]
        )

# =============== Analytics Tools ===============

@mcp.tool()
def pm_my_queue(input: MyQueueInput) -> Dict[str, Any]:
    """
    Get personalized work queue with intelligent prioritization.
    Helps agents focus on the most important work.
    """
    owner = input.owner or Config.DEFAULT_OWNER

    try:
        with DatabaseSession():
            # Get assigned issues
            my_issues = PMDatabase.get_issues(owner=owner, limit=100)

            # Filter to actionable statuses
            actionable = [
                i for i in my_issues
                if i['status'] in ['proposed', 'in_progress', 'review']
            ]

            # Add blocked issues that might be unblockable
            if input.include_blocked:
                blocked_issues = PMDatabase.get_blocked_issues()
                all_issues = PMDatabase.get_issues(limit=1000)

                for blocked in blocked_issues:
                    deps = analyze_dependencies(blocked, all_issues)
                    if deps['ready_to_work']:
                        blocked['unblockable'] = True
                        actionable.append(blocked)

            # Sort based on criteria
            if input.sort_by == 'priority':
                priority_order = {'P1': 1, 'P2': 2, 'P3': 3, 'P4': 4, 'P5': 5}
                actionable.sort(key=lambda i: priority_order.get(i['priority'], 6))
            elif input.sort_by == 'urgency':
                actionable.sort(key=calculate_urgency_score, reverse=True)
            elif input.sort_by == 'dependency':
                # Sort by blocking others first, then by dependency count
                all_issues = PMDatabase.get_issues(limit=1000)
                def dep_score(issue):
                    deps = analyze_dependencies(issue, all_issues)
                    return (deps['blocking_count'] * 10) - deps['dependency_count']
                actionable.sort(key=dep_score, reverse=True)
            else:  # age
                actionable.sort(key=lambda i: i['created_utc'])

            # Format queue with recommendations
            queue = []
            for issue in actionable[:input.limit]:
                age_days = (datetime.utcnow() - datetime.fromisoformat(issue['created_utc'].rstrip('Z'))).days

                item = {
                    "key": issue['key'],
                    "title": issue['title'],
                    "type": issue['type'],
                    "status": issue['status'],
                    "priority": issue['priority'],
                    "age_days": age_days,
                    "urgency_score": calculate_urgency_score(issue)
                }

                # Add actionable recommendations
                if issue['status'] == 'proposed':
                    item['recommended_action'] = "pm_start_work"
                elif issue['status'] == 'in_progress':
                    item['recommended_action'] = "pm_log_work or pm_commit"
                elif issue['status'] == 'review':
                    item['recommended_action'] = "pm_push_branch --create-pr"
                elif issue['status'] == 'blocked' and issue.get('unblockable'):
                    item['recommended_action'] = "pm_update_status --status in_progress"

                queue.append(item)

            hints = []
            if queue:
                top_item = queue[0]
                hints.append(f"Focus on {top_item['key']}: {top_item['title']} ({top_item['recommended_action']})")
            else:
                hints.append("Queue is empty - consider pm_create_issue to add new work")

            if len(actionable) > input.limit:
                hints.append(f"Showing top {input.limit} of {len(actionable)} actionable items")

            return standard_response(
                success=True,
                message=f"Work queue for {owner}",
                data={
                    "owner": owner,
                    "queue": queue,
                    "total_assigned": len(my_issues),
                    "actionable_count": len(actionable),
                    "sort_method": input.sort_by
                },
                hints=hints
            )

    except Exception as e:
        return standard_response(
            success=False,
            message=f"Failed to get work queue: {type(e).__name__}",
            hints=["Check database connectivity"]
        )

@mcp.tool()
def pm_blocked_issues(input: BlockedIssuesInput) -> Dict[str, Any]:
    """
    Find and analyze blocked issues with unblocking recommendations.
    Helps identify systematic blockers and resolution paths.
    """
    try:
        with DatabaseSession():
            blocked = PMDatabase.get_blocked_issues(project_id=input.project_id)

            if not blocked:
                return standard_response(
                    success=True,
                    message="No blocked issues found",
                    data={"blocked_issues": [], "total_blocked": 0},
                    hints=["Great! No blockers to resolve"]
                )

            all_issues = PMDatabase.get_issues(project_id=input.project_id, limit=1000)
            result_issues = []

            for issue in blocked:
                blocked_info = {
                    'issue': issue,
                    'can_unblock': False,
                    'unblock_actions': [],
                    'days_blocked': 0
                }

                # Analyze dependencies
                deps = analyze_dependencies(issue, all_issues)
                blocked_info['can_unblock'] = deps['ready_to_work']

                if deps['ready_to_work']:
                    blocked_info['unblock_actions'].append('All dependencies completed - ready to resume')
                else:
                    pending = [d['key'] for d in deps['depends_on'] if not d['ready']]
                    blocked_info['unblock_actions'].append(f"Waiting for: {', '.join(pending)}")

                # Check how long it's been blocked
                updated = datetime.fromisoformat(issue['updated_utc'].rstrip('Z'))
                days_blocked = (datetime.utcnow() - updated).days
                blocked_info['days_blocked'] = days_blocked

                if input.include_stale and days_blocked > 7:
                    blocked_info['unblock_actions'].append(f'Blocked for {days_blocked} days - review if still valid')
                    blocked_info['stale'] = True

                # Include based on filters
                if input.actionable_only:
                    if blocked_info['can_unblock'] or (input.include_stale and days_blocked > 7):
                        result_issues.append(blocked_info)
                else:
                    result_issues.append(blocked_info)

            # Sort by actionability and age
            result_issues.sort(key=lambda x: (x['can_unblock'], -x['days_blocked']), reverse=True)

            recommendations = []
            for item in result_issues[:5]:
                if item['can_unblock']:
                    recommendations.append(f"Unblock {item['issue']['key']}: {item['issue']['title']}")

            hints = []
            actionable_count = len([i for i in result_issues if i['can_unblock']])
            if actionable_count > 0:
                hints.append(f"{actionable_count} issues can be unblocked now")
            if len(result_issues) > actionable_count:
                hints.append(f"{len(result_issues) - actionable_count} issues still waiting on dependencies")

            return standard_response(
                success=True,
                message=f"Found {len(result_issues)} blocked issues",
                data={
                    "blocked_issues": result_issues,
                    "total_blocked": len(blocked),
                    "actionable": actionable_count,
                    "recommendations": recommendations
                },
                hints=hints
            )

    except Exception as e:
        return standard_response(
            success=False,
            message=f"Failed to analyze blocked issues: {type(e).__name__}",
            hints=["Check database connectivity"]
        )

# =============== Workflow Tools ===============

@mcp.tool()
def pm_daily_standup(input: DailyStandupInput) -> Dict[str, Any]:
    """
    Generate daily standup report with yesterday's work, today's plan, and blockers.
    Perfect for automated status updates and team synchronization.
    """
    project_id = input.project_id or get_default_project_id()
    owner = input.owner or Config.DEFAULT_OWNER

    try:
        with DatabaseSession():
            # Get yesterday's work logs
            yesterday = datetime.utcnow() - timedelta(days=1)
            yesterday_work = PMDatabase.get_recent_worklogs(
                project_id=project_id,
                limit=50
            )

            # Filter to yesterday and specific owner
            yesterday_work = [
                w for w in yesterday_work
                if (datetime.fromisoformat(w['timestamp_utc'].rstrip('Z')).date() == yesterday.date() and
                    w.get('agent') == owner)
            ]

            # Get today's planned work (in_progress issues)
            today_issues = PMDatabase.get_issues(
                project_id=project_id,
                owner=owner,
                status='in_progress',
                limit=10
            )

            # Get blockers
            blocked_issues = PMDatabase.get_blocked_issues(project_id=project_id)

            # Format based on requested format
            if input.format == 'markdown':
                content = format_standup_report(yesterday_work, today_issues, blocked_issues)
            elif input.format == 'structured':
                content = {
                    "date": datetime.now().strftime('%Y-%m-%d'),
                    "yesterday": [
                        {
                            "issue": w['issue_key'],
                            "activity": w.get('activity', 'unknown'),
                            "summary": w['summary']
                        } for w in yesterday_work
                    ],
                    "today": [
                        {
                            "issue": i['key'],
                            "title": i['title'],
                            "priority": i['priority']
                        } for i in today_issues
                    ],
                    "blockers": [
                        {
                            "issue": b['key'],
                            "title": b['title'],
                            "blocked_since": b['updated_utc']
                        } for b in blocked_issues
                    ]
                }
            else:  # text
                lines = [f"Daily Standup - {datetime.now().strftime('%Y-%m-%d')}"]
                lines.append(f"\nOwner: {owner}")
                lines.append("\nYesterday:")
                for w in yesterday_work:
                    lines.append(f"- {w['issue_key']}: {w['summary']}")
                if not yesterday_work:
                    lines.append("- No logged work yesterday")

                lines.append("\nToday:")
                for i in today_issues:
                    lines.append(f"- {i['key']}: {i['title']} ({i['priority']})")
                if not today_issues:
                    lines.append("- No active issues")

                lines.append("\nBlockers:")
                for b in blocked_issues[:3]:  # Limit to prevent spam
                    lines.append(f"- {b['key']}: {b['title']}")
                if not blocked_issues:
                    lines.append("- No blockers")

                content = "\n".join(lines)

            hints = []
            if not yesterday_work:
                hints.append("No work logged yesterday - consider pm_log_work for better tracking")
            if not today_issues:
                hints.append("No active work - use pm_my_queue to find work or pm_create_issue to add new work")
            if blocked_issues:
                hints.append(f"pm_blocked_issues to analyze {len(blocked_issues)} blocked items")

            return standard_response(
                success=True,
                message=f"Daily standup for {owner}",
                data={
                    "report": content,
                    "format": input.format,
                    "stats": {
                        "yesterday_items": len(yesterday_work),
                        "today_items": len(today_issues),
                        "blockers": len(blocked_issues)
                    },
                    "project": project_id,
                    "owner": owner
                },
                hints=hints
            )

    except Exception as e:
        return standard_response(
            success=False,
            message=f"Failed to generate standup: {type(e).__name__}",
            hints=["Check database connectivity", "Verify project exists"]
        )

# =============== Main Entry Point ===============

def main():
    """Main entry point for the MCP server with proper configuration handling"""
    import argparse

    parser = argparse.ArgumentParser(description="PM MCP Server - LLM-Native Project Management")
    parser.add_argument("--transport", choices=["stdio", "http", "sse"],
                       default=Config.DEFAULT_TRANSPORT,
                       help="Transport method")
    parser.add_argument("--port", type=int, default=Config.DEFAULT_PORT,
                       help="Port for HTTP transport")
    parser.add_argument("--host", default=Config.DEFAULT_HOST,
                       help="Host for HTTP transport")
    parser.add_argument("--validate-config", action="store_true",
                       help="Validate configuration and exit")
    parser.add_argument("--database-path", type=str,
                       help="Override database path")

    args = parser.parse_args()

    # Override database path if provided
    if args.database_path:
        Config.set_database_path(args.database_path)

    # Validate configuration
    if args.validate_config:
        is_valid, messages = Config.validate(strict=False)
        print(f"{'✅' if is_valid else '⚠️'} Configuration:")

        config_summary = Config.get_summary()
        for key, value in config_summary.items():
            print(f"   {key}: {value}")

        print("\nValidation messages:")
        for msg in messages:
            print(f"   - {msg}")

        return 0 if is_valid else 1

    # Initialize database connection
    try:
        PMDatabase.initialize()
        print(f"✅ Connected to database: {Config.get_database_path()}")

        # Get project count for validation
        with DatabaseSession():
            projects = PMDatabase.get_all_projects()
            print(f"   Found {len(projects)} projects")

            if projects and not Config.DEFAULT_PROJECT_ID:
                print(f"   Using first project as default: {projects[0]['project_id']}")

    except Exception as e:
        print(f"❌ Database error: {e}")
        print(f"   Database path: {Config.get_database_path()}")
        print(f"   Run the Jira-lite migration first if database doesn't exist")
        return 1

    # Start server
    print(f"🚀 Starting PM MCP Server")
    print(f"   Transport: {args.transport}")

    if args.transport == "stdio":
        print(f"   Mode: Standard I/O for Claude Desktop")
        mcp.run()
    else:
        print(f"   URL: http://{args.host}:{args.port}")
        # For HTTP mode, FastMCP might have different parameters
        try:
            mcp.run(port=args.port)
        except TypeError:
            # Fallback to basic run
            mcp.run()

# =============== Initialization Tools ===============

@mcp.tool()
def pm_init_project(project_path: str = ".", project_name: Optional[str] = None) -> Dict[str, Any]:
    """
    Initialize a new project for PM tracking. Scans directory structure,
    creates project metadata, and generates stable project ID.
    """
    try:
        project_dir = Path(project_path).resolve()
        if not project_dir.exists() or not project_dir.is_dir():
            return err(f"Invalid project path: {project_path}",
                      hints=["Ensure path exists and is a directory"])

        # Generate project slug from directory name or provided name
        slug = project_name or project_dir.name
        slug = slug.lower().replace('_', '-').replace(' ', '-')

        # Generate stable project ID
        import hashlib
        path_str = str(project_dir)
        project_id = f"pn_{hashlib.md5(path_str.encode()).hexdigest()}"

        # Detect git repository
        vcs_info = {}
        git_result = run_git(str(project_dir), ['status'])
        if git_result['rc'] == 0:
            # Get default branch
            branch_result = run_git(str(project_dir), ['branch', '--show-current'])
            default_branch = branch_result['out'] if branch_result['rc'] == 0 else 'main'

            # Get remote URL if exists
            remote_result = run_git(str(project_dir), ['remote', 'get-url', 'origin'])
            remote_url = remote_result['out'] if remote_result['rc'] == 0 else None

            vcs_info = {
                'git_root': str(project_dir),
                'default_branch': default_branch,
                'remote_url': remote_url
            }
        else:
            vcs_info = {
                'git_root': str(project_dir),
                'default_branch': 'main',
                'is_git_repo': False
            }

        # Detect submodules/modules
        submodules = []
        common_dirs = ['src', 'frontend', 'backend', 'api', 'web', 'mobile', 'docs', 'tests']

        for subdir in project_dir.iterdir():
            if subdir.is_dir() and subdir.name in common_dirs:
                submodules.append({
                    'name': subdir.name,
                    'path': subdir.name,
                    'absolute_path': str(subdir),
                    'manage_separately': subdir.name in ['frontend', 'backend', 'api', 'web', 'mobile']
                })

        # Create project data
        project_data = {
            'project_id': project_id,
            'project_slug': slug,
            'absolute_path': str(project_dir),
            'submodules': submodules,
            'vcs': vcs_info,
            'mcp': {
                'pm_server_name': 'pm',
                'version': '>=1.0.0'
            }
        }

        # Add to database
        with DatabaseSession():
            # Check if project already exists
            existing = PMDatabase.get_project(project_id)
            if existing:
                return ok(f"Project already initialized: {slug}", {
                    "project": existing,
                    "already_exists": True
                }, hints=[
                    f"pm_register_project to register with web UI",
                    f"pm_status --project-id {project_id} to see project health"
                ])

            # Create project metadata
            metadata = {
                'submodules': submodules,
                'vcs': vcs_info,
                'mcp': project_data['mcp']
            }

            from database import Project
            project = Project.create(
                project_id=project_id,
                project_slug=slug,
                absolute_path=str(project_dir),
                metadata=json.dumps(metadata),
                created_utc=datetime.utcnow(),
                updated_utc=datetime.utcnow()
            )

            result_data = {
                "project": {
                    "project_id": project_id,
                    "project_slug": slug,
                    "absolute_path": str(project_dir),
                    "submodules": submodules,
                    "vcs": vcs_info,
                    "mcp": project_data['mcp']
                },
                "detected": {
                    "git_repository": git_result['rc'] == 0,
                    "submodules_found": len(submodules),
                    "default_branch": vcs_info.get('default_branch')
                }
            }

            return ok(f"Initialized project: {slug}", result_data, hints=[
                f"pm_register_project to register with web UI",
                f"pm_create_issue to start adding work",
                f"Set PM_DEFAULT_PROJECT_ID={project_id} for convenience"
            ])

    except Exception as e:
        return err(f"Failed to initialize project: {type(e).__name__}",
                  hints=["Check directory permissions", "Ensure git is available if using git repository"])

@mcp.tool()
def pm_register_project(server_url: str = "http://127.0.0.1:1929",
                       project_id: Optional[str] = None) -> Dict[str, Any]:
    """
    Register project with Jira-lite web UI server.
    Enables bidirectional sync between MCP and web interface.
    """
    try:
        project_id = project_id or get_default_project_id()
        if not project_id:
            return standard_response(
                success=False,
                message="No project specified and none found",
                hints=["Run pm_init_project first", "Use pm_list_projects to see available projects"]
            )

        with DatabaseSession():
            project = PMDatabase.get_project(project_id)
            if not project:
                return standard_response(
                    success=False,
                    message=f"Project {project_id} not found",
                    hints=["Run pm_init_project first"]
                )

            # Prepare registration data
            registration_data = {
                'project_id': project['project_id'],
                'project_slug': project['project_slug'],
                'absolute_path': project['absolute_path'],
                'submodules': project.get('submodules', []),
                'vcs': project.get('vcs', {}),
                'mcp': project.get('mcp', {})
            }

            # Try to register with web UI
            try:
                import requests
                response = requests.post(
                    f"{server_url}/api/projects/register",
                    json=registration_data,
                    timeout=10
                )

                if response.status_code in [200, 201]:
                    result = response.json()
                    return standard_response(
                        success=True,
                        message=f"Registered project with web UI: {result.get('slug')}",
                        data={
                            "registration": result,
                            "dashboard_url": result.get('dashboard_url'),
                            "server_url": server_url
                        },
                        hints=[
                            f"Visit dashboard: {result.get('dashboard_url')}",
                            "pm_create_issue to start adding work"
                        ]
                    )
                else:
                    return standard_response(
                        success=False,
                        message=f"Registration failed: HTTP {response.status_code}",
                        data={"response": response.text[:200]},
                        hints=["Ensure Jira-lite server is running", f"Check server URL: {server_url}"]
                    )

            except ImportError:
                return standard_response(
                    success=False,
                    message="requests library not available for web UI registration",
                    hints=["Install requests: pip install requests", "Or register manually via web UI"]
                )
            except Exception as e:
                return standard_response(
                    success=False,
                    message=f"Registration failed: {type(e).__name__}",
                    hints=[
                        "Ensure Jira-lite server is running",
                        f"Check server URL: {server_url}",
                        "Verify network connectivity"
                    ]
                )

    except Exception as e:
        return standard_response(
            success=False,
            message=f"Failed to register project: {type(e).__name__}",
            hints=["Check database connectivity", "Verify project exists"]
        )

# =============== Critical Missing Tools ===============

@mcp.tool()
def pm_estimate(input: EstimateIssueInput) -> Dict[str, Any]:
    """Add effort and complexity estimates to an issue with detailed reasoning"""
    try:
        with DatabaseSession():
            issue = PMDatabase.get_issue(input.issue_key)
            if not issue:
                return err(f"Issue not found: {input.issue_key}")

            issue = PMDatabase.update_issue_planning_estimate(
                issue, effort=input.effort, complexity=input.complexity, reasoning=input.reasoning
            )

            return ok("Estimate updated", {
                "issue_key": issue.key,
                "estimated_effort": input.effort,
                "complexity": input.complexity
            }, hints=[
                f"pm_start_work --issue-key {input.issue_key} to begin implementation"
            ])
    except Exception as e:
        return err("Failed to update estimate", {"exception": str(e)})

@mcp.tool()
def pm_create_task(input: CreateTaskInput) -> Dict[str, Any]:
    """Create a task within an issue for work breakdown"""
    try:
        with DatabaseSession():
            issue = PMDatabase.get_issue(input.issue_key)
            if not issue:
                return err(f"Issue not found: {input.issue_key}")

            task = PMDatabase.create_task(issue, input.title, input.assignee, input.details)

            return ok("Task created", {
                "task_id": task.task_id,
                "title": task.title,
                "status": task.status,
                "issue_key": input.issue_key
            }, hints=[
                f"pm_update_task --task-id {task.task_id} to update status",
                f"pm_log_work --issue-key {input.issue_key} --task-id {task.task_id} to log task work"
            ])
    except Exception as e:
        return err("Failed to create task", {"exception": str(e)})

@mcp.tool()
def pm_update_task(input: UpdateTaskInput) -> Dict[str, Any]:
    """Update task status, title, assignee, or details"""
    try:
        with DatabaseSession():
            task = PMDatabase.get_task(input.task_id)
            if not task:
                return err(f"Task not found: {input.task_id}")

            task = PMDatabase.update_task(task, input.title, input.status, input.assignee, input.details)

            return ok("Task updated", {
                "task_id": task.task_id,
                "title": task.title,
                "status": task.status,
                "assignee": task.assignee
            })
    except Exception as e:
        return err("Failed to update task", {"exception": str(e)})

@mcp.tool()
def pm_git_status(project_id: Optional[str] = None) -> Dict[str, Any]:
    """Enhanced git status with issue context"""
    try:
        with DatabaseSession():
            pid = project_id or get_default_project_id()
            if not pid:
                return err("No project_id provided and PM_DEFAULT_PROJECT_ID is not set")

            project = PMDatabase.get_project(pid)
            if not project:
                return err(f"Project not found: {pid}")

            project_dict = PMDatabase._project_to_dict(project)
            repo_path = project_dict.get('vcs', {}).get('git_root', project_dict['absolute_path'])

            br = git_current_branch(repo_path)
            st = git_status(repo_path)

            data = {
                "project": project_dict['project_slug'],
                "branch": br["out"] if br["rc"] == 0 else None,
                "status": st["out"] if st["rc"] == 0 else "",
                "has_changes": bool(st["out"].strip()) if st["rc"] == 0 else False
            }

            hints = []
            if st["out"]:
                hints.append("You have local changes. Consider committing before push.")

            return ok("Git status", data, hints=hints)
    except Exception as e:
        return err("Failed to get git status", {"exception": str(e)})

@mcp.tool()
def pm_push_branch(project_id: Optional[str] = None, remote: str = "origin") -> Dict[str, Any]:
    """Push current branch to remote"""
    try:
        with DatabaseSession():
            pid = project_id or get_default_project_id()
            if not pid:
                return err("No project_id provided and PM_DEFAULT_PROJECT_ID is not set")

            project = PMDatabase.get_project(pid)
            if not project:
                return err(f"Project not found: {pid}")

            project_dict = PMDatabase._project_to_dict(project)
            repo_path = project_dict.get('vcs', {}).get('git_root', project_dict['absolute_path'])

            res = git_push_current(repo_path, remote=remote)
            if res["rc"] != 0:
                return err("Push failed", {"stderr": res["err"]})

            return ok("Branch pushed", {
                "stdout": res["out"],
                "remote": remote
            }, hints=["Create a PR in your VCS host if desired."])
    except Exception as e:
        return err("Failed to push branch", {"exception": str(e)})

@mcp.tool()
def pm_project_dashboard(input: ProjectDashboardInput) -> Dict[str, Any]:
    """Get comprehensive project dashboard with metrics"""
    try:
        with DatabaseSession():
            pid = input.project_id or get_default_project_id()
            if not pid:
                return err("No project_id provided and PM_DEFAULT_PROJECT_ID is not set")

            project = PMDatabase.get_project(pid)
            if not project:
                return err(f"Project not found: {pid}")

            project_dict = PMDatabase._project_to_dict(project)
            metrics = PMDatabase.project_metrics(project)

            return ok("Project dashboard", {
                "project": project_dict,
                "metrics": metrics,
                "timeframe": input.timeframe
            })
    except Exception as e:
        return err("Failed to compute dashboard", {"exception": str(e)})

if __name__ == "__main__":
    sys.exit(main())